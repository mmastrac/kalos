"import module;\n"
"import kidl;\n"
"\n"
"var in_object = false;\n"
"var in_module = false;\n"
"var is_dynamic = false;\n"
"var is_internal = false;\n"
"var dispatch = \"\";\n"
"var dynamic_dispatch = \"\";\n"
"var current_module;\n"
"var undef = \"\";\n"
"\n"
"# Why so many weird macros?\n"
"\n"
"# The IDL compiler makes use of macros to assist with self-hosting development. It can be\n"
"# painful to update the dispatch-generating code at the same time as changes are being made\n"
"# to the dispatch interface. Macros de-couple the generated code somewhat from the interface\n"
"# and allow much simpler hand-edits to be made for bootstrapping purposes.\n"
"\n"
"const FORWARD = \"forward\";  # Forward declaration phase\n"
"const IMPL = \"impl\";        # Implementation phase\n"
"const HANDLE = \"handler\";\n"
"const DISPATCH = \"dispatch\";\n"
"const OBJECT = \"object\";\n"
"const TYPES = [\n"
"    [\"string\",  \"STRING\",   \"kalos_string\", \"*\",      \"kalos_string_release((kalos_state*)state, x);\"],\n"
"    [\"number\",  \"NUMBER\",   \"kalos_int\", \"\",          \";\"],\n"
"    [\"bool\",    \"BOOL\",     \"kalos_int\", \"\",          \";\"],\n"
"    [\"object\",  \"OBJECT\",   \"kalos_object_ref\", \"*\",  \"kalos_object_release((kalos_state*)state, &x);\"],\n"
"    [\"any\",     \"ANY\",      \"kalos_value\", \"*\",       \"kalos_clear((kalos_state*)state, &x);\"],\n"
"];\n"
"\n"
"fn write_matcher(id, name, arg_count) {\n"
"    println(\"\\tif (K__match(/*id=*/{id}, /*args=*/{arg_count}, /*name=*/{name})) {{\");\n"
"}\n"
"\n"
"fn write_binding(binding, arg_types, vararg_type) {\n"
"    var index = 0;\n"
"    var arg;\n"
"    if binding.type == \"c\" {\n"
"        var c = binding.value;\n"
"        for arg in arg_types {\n"
"            c = replace(c, \"@\" + index, \"(K__arg_{arg}(K__arg(arg_count, {index+1})))\");\n"
"            index += 1;\n"
"        }\n"
"        if (c) {\n"
"            print(\"({c})\");\n"
"        }\n"
"    } else {\n"
"        print(\"{binding.value}((void*)state\");\n"
"        if (is_internal) {\n"
"            print(\", op\");\n"
"        }\n"
"        for arg in arg_types {\n"
"            print(\", K__arg_{arg}(K__arg(arg_count, {index+1}))\");\n"
"            index += 1;\n"
"        }\n"
"        if vararg_type != \"void\" {\n"
"            print(\", vararg_count, kalos_stack_vararg_start(stack, vararg_count)\");\n"
"        }\n"
"        print(\")\");\n"
"    }\n"
"}\n"
"\n"
"fn write_invoke(args, arg_count, varargs, return_type, binding) {\n"
"    if varargs == \"void\" {\n"
"        println(\"\\t\\tconst int arg_count = {arg_count};\");\n"
"    } else {\n"
"        println(\"\\t\\tconst int vararg_count = kalos_stack_vararg_count(stack);\");\n"
"        println(\"\\t\\tconst int arg_count = {arg_count + 1} + vararg_count;\");\n"
"    }\n"
"    print(\"\\t\\tif (kalos_stack_setup_{arg_count}(state, arg_count\");\n"
"    var arg;\n"
"    for arg in args {\n"
"        print(\", K__t_{arg}\");\n"
"    }\n"
"    println(\")) {{\");\n"
"    print(\"\\t\\t\\t\");\n"
"    if return_type != \"void\" {\n"
"        print(\"K__{return_type} x = \");\n"
"    }\n"
"    write_binding(binding, args, varargs);\n"
"    println(\";\");\n"
"    println(\"\\t\\t\\tkalos_stack_cleanup(state, arg_count);\");\n"
"    if return_type != \"void\" {\n"
"        println(\"\\t\\t\\tK__final_{return_type}(stack, x);\");\n"
"    }\n"
"    println(\"\\t\\t\\treturn true;\");\n"
"    println(\"\\t\\t}}\");\n"
"    println(\"\\t}}\");\n"
"    println(\"\");\n"
"}\n"
"\n"
"fn define_args(prefix, args, name, value) {\n"
"    println(\"#define {prefix + name + args:<25} {value}\");\n"
"    undef += \"#undef {prefix + name}\\n\";\n"
"}\n"
"\n"
"fn define(prefix, name, value) {\n"
"    println(\"#define {prefix + name:<15} {value}\");\n"
"    undef += \"#undef {prefix + name}\\n\";\n"
"}\n"
"\n"
"on open(flags) {\n"
"    is_dynamic = flags == 1;\n"
"    is_internal = flags == 2;\n"
"    println(\"/* Generated by kalos_idl_compiler - DO NOT MODIFY */\");\n"
"    println(\"\");\n"
"    var type;\n"
"    for type in TYPES {\n"
"        define(\"K__p\", type[0], type[2] + type[3]);\n"
"        define(\"K__\", type[0], type[2]);\n"
"    }\n"
"    println(\"\");\n"
"    for type in TYPES {\n"
"        define(\"K__t_\", type[0], \"KALOS_VALUE_{type[1]}\");\n"
"    }\n"
"    println(\"\");\n"
"    for type in TYPES {\n"
"        if is_internal {\n"
"            define_args(\"K__final_\", \"(stack, x)\", type[0], \"push_{type[0]}(stack, x);\");\n"
"        } else {\n"
"            define_args(\"K__final_\", \"(stack, x)\", type[0], \"if (retval) {{ push_{type[0]}(stack, x); }} else {{ {type[4]}; }}\");\n"
"        }\n"
"    }\n"
"    define_args(\"K__arg\",  \"(n, x)\", \"\",    \"peek(stack, (n)-(x))\");\n"
"    define_args(\"K__arg_\", \"(x)\",    \"string\", \"&((x)->value.string)\");\n"
"    define_args(\"K__arg_\", \"(x)\",    \"number\", \"(x)->value.number\");\n"
"    define_args(\"K__arg_\", \"(x)\",    \"bool\",   \"(x)->value.number\");\n"
"    define_args(\"K__arg_\", \"(x)\",    \"object\", \"&((x)->value.object)\");\n"
"    define_args(\"K__arg_\", \"(x)\",    \"any\",    \"(x)\");\n"
"\n"
"    if flags == 0 {\n"
"        # Standard mode\n"
"        define_args(\"K__match\", \"(id, n, s)\", \"\", \"(param_count == n && function == id)\");\n"
"    } else if flags == 1 {\n"
"        # Dynamic mode\n"
"        define_args(\"K__match\", \"(id, n, s)\", \"\", \"(param_count == n && strcmp(name, #s) == 0)\");\n"
"    } else if flags == 2 {\n"
"        # Internal mode\n"
"        define_args(\"K__match\", \"(id, n, s)\", \"\", \"(op == KALOS_OP_##s)\");\n"
"    }\n"
"    println(\"\");\n"
"    kidl.walk_modules(FORWARD);\n"
"    kidl.walk_modules(IMPL);\n"
"}\n"
"\n"
"on close {\n"
"    if is_dynamic {\n"
"        println(\"bool {kidl.prefix}dynamic_dispatch(kalos_run_state* state, const char* module, const char* name, int param_count, kalos_stack* stack, bool retval) {{\");\n"
"        println(dynamic_dispatch);\n"
"        println(\"\\tLOG(\\\"Module %s not found\\\", module);\");\n"
"        println(\"\\treturn false;\");\n"
"        println(\"}}\");\n"
"        println(\"\");\n"
"    } else if !is_internal {\n"
"        println(\"kalos_dispatch_fn {kidl.prefix}dispatch[] = {{\");\n"
"        print(dispatch);\n"
"        println(\"}};\");\n"
"        println(\"\");\n"
"    }\n"
"    print(undef);\n"
"}\n"
"\n"
"on module.begin(context, m) {\n"
"    current_module = m;\n"
"    if context == IMPL {\n"
"        dispatch += \"\\t{kidl.prefix}{m.name},\\n\";\n"
"        module.walk_exports(HANDLE);\n"
"        if is_dynamic {\n"
"            dynamic_dispatch += \"\\tif (strcmp(module, \\\"{m.name}\\\") == 0) {{ return {kidl.prefix}{m.name}_dynamic_dispatch(state, name, param_count, stack, retval); }}\\n\";\n"
"            println(\"bool {kidl.prefix}{m.name}_dynamic_dispatch(kalos_run_state* state, const char* name, int param_count, kalos_stack* stack, bool retval) {{\");\n"
"        } else if is_internal {\n"
"            println(\"static inline bool {kidl.prefix}{m.name}(kalos_run_state* state, kalos_op op, kalos_stack* stack) {{\");\n"
"        } else {\n"
"            println(\"bool {kidl.prefix}{m.name}(kalos_run_state* state, int function, int param_count, kalos_stack* stack, bool retval) {{\");\n"
"        }\n"
"        in_module = true;\n"
"        module.walk_exports(DISPATCH);\n"
"        in_module = false;\n"
"        println(\"\\treturn false;\");\n"
"        println(\"}}\");\n"
"        println(\"\");\n"
"    } else {\n"
"        module.walk_exports(FORWARD);\n"
"        #println(\"\");\n"
"    }\n"
"}\n"
"\n"
"on module.handler(context, handler) {\n"
"    if context != HANDLE {\n"
"        return;\n"
"    }\n"
"    println(\"// id={handler.module_index:04x}:{handler.handler_index:04x} name={handler.name}\");\n"
"    if current_module.name == \"builtin\" {\n"
"        print(\"void {kidl.prefix}trigger_{handler.name}(kalos_run_state* state\");\n"
"    } else {\n"
"        print(\"void {kidl.prefix}{current_module.name}_trigger_{handler.name}(kalos_run_state* state\");\n"
"    }\n"
"    var index = 0;\n"
"    var arg;\n"
"    for arg in handler.args {\n"
"        print(\", K__p{arg} a{index}\");\n"
"        index += 1;\n"
"    }\n"
"    println(\") {{\");\n"
"    index = 0;\n"
"    for arg in handler.args {\n"
"        println(\"\\tkalos_load_arg_{arg}(state, {index}, a{index});\");\n"
"        index += 1;\n"
"    }\n"
"    println(\"\\tkalos_trigger(state, kalos_make_address({handler.module_index:#x}, {handler.handler_index:#x}));\");\n"
"    println(\"}}\");\n"
"    println(\"\");\n"
"}\n"
"\n"
"on module.object(context, object) {\n"
"    if context != HANDLE {\n"
"        return;\n"
"    }\n"
"    println(\"//{kidl.prefix}{current_module.name}_object_{object.name}_props\");\n"
"    if is_dynamic {\n"
"        println(\"bool {kidl.prefix}{current_module.name}_object_{object.name}_props_fn(kalos_run_state* state, kalos_object_ref* object, const char* name, int param_count, kalos_stack* stack) {{\");\n"
"    } else {\n"
"        println(\"bool {kidl.prefix}{current_module.name}_object_{object.name}_props_fn(kalos_run_state* state, kalos_object_ref* object, int function, int param_count, kalos_stack* stack) {{\");\n"
"    }\n"
"    println(\"\\tbool retval = true;\");\n"
"    in_object = true;\n"
"    module.walk_object_properties(OBJECT, object);\n"
"    in_object = false;\n"
"    println(\"\\treturn false;\");\n"
"    println(\"}}\");\n"
"    println(\"\");\n"
"    println(\"kalos_object_dispatch {kidl.prefix}{current_module.name}_object_{object.name}_props = {{\");\n"
"    if is_dynamic {\n"
"        println(\"\\t.dispatch_name = {kidl.prefix}{current_module.name}_object_{object.name}_props_fn\");\n"
"    } else {\n"
"        println(\"\\t.dispatch_id = {kidl.prefix}{current_module.name}_object_{object.name}_props_fn\");\n"
"    }\n"
"    println(\"}};\");\n"
"    println(\"\");\n"
"}\n"
"\n"
"on module.function(context, function) {\n"
"    if context != DISPATCH {\n"
"        return;\n"
"    }\n"
"    var overload;\n"
"    var arg;\n"
"    for overload in function.overloads {\n"
"        println(\"\\t// id={overload.binding.invoke_id} name={function.name} arg_count={overload.arg_count} binding={overload.binding.type} {overload.binding.value}\");\n"
"        write_matcher(overload.binding.invoke_id, function.name, overload.arg_count);\n"
"        write_invoke(overload.args, overload.arg_count, overload.varargs, overload.return_type, overload.binding);\n"
"    }\n"
"}\n"
"\n"
"on module.property(context, property) {\n"
"    if !in_module && !in_object {\n"
"        return;\n"
"    }\n"
"    if property.read_binding.invoke_id != 0 {\n"
"        println(\"\\t// id={property.read_binding.invoke_id} name={property.name} binding={property.read_binding.type} {property.read_binding.value}\");\n"
"        write_matcher(property.read_binding.invoke_id, property.name, 0);\n"
"        if in_object {\n"
"            write_invoke([\"object\"], 1, \"void\", property.type, property.read_binding);\n"
"        } else {\n"
"            write_invoke([], 0, \"void\", property.type, property.read_binding);\n"
"        }\n"
"    }\n"
"    if property.write_binding.invoke_id != 0 {\n"
"        println(\"\\t// id={property.write_binding.invoke_id} name={property.name} binding={property.write_binding.type} {property.write_binding.value}\");\n"
"        write_matcher(property.write_binding.invoke_id, property.name, 1);\n"
"        if in_object {\n"
"            write_invoke([\"object\", property.type], 2, \"void\", \"void\", property.write_binding);\n"
"        } else {\n"
"            write_invoke([property.type], 1, \"void\", \"void\", property.write_binding);\n"
"        }\n"
"    }\n"
"}\n"
""
