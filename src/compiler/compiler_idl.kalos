var lexer;

on kidl.resolve_list_object_prop(type, property, list): any {
    if property == @@(.name) {
        return type + "=" + list[0];
    } else if property == @@(.return_type) {
        return type + "=" + list[1];
    } else if property == @@(.b) {
        return type + "=" + list[2];
    }
    return "unknown";
}

fn idl_error(s) {
    print("ERROR: {s}\n");
    sys.exit(1);
}

fn idl_log(s) {
    print("LOG: {s}\n");
}

fn expect_word(): string {
    var next = lexer.read;
    if next.token == "WORD" {
        idl_log("    token = {next.token} string = {next.string}");
        return next.string;
    }
    if next.is_word {
        return next.string;
    }
    idl_error("Expected WORD, but got token {next.token}");
    return "<error>";
}

fn expect_token(token): object {
    var next = lexer.read;
    if next.token != token {
        idl_error("Expected {token} but got {next.token}");
    }
    return next;
}

fn parse_idl_type(): object {
    if lexer.peek.token == "COLON" {
        expect_token("COLON");
        var type = lexer.read.string;
        idl_log("  type: {type}");
        return type;
    }
    return "void";
}

fn parse_idl_args(): object {
    var args = [];
    expect_token("PAREN_OPEN");
    if lexer.peek.token != "PAREN_CLOSE" {
        loop {
            var param_name = expect_word();
            var param_type = parse_idl_type();
            append(args, [param_name, param_type]);
            if lexer.peek.token == "PAREN_CLOSE" {
                break;
            }
            expect_token("COMMA");
        }
    }
    expect_token("PAREN_CLOSE");
    return args;
}

fn parse_idl_binding(): object {
    expect_token("EQ");
    var retval;
    if lexer.peek.token == "C" {
        expect_token("C");
        var token = expect_token("STRING_LITERAL");
        retval = ["c", token.string];
    } else {
        var word = expect_word();
        retval = ["fn", word];
    }
    expect_token("SEMI");
    idl_log("  binding: {retval}");
    return retval;
}

fn parse_idl_prop(): object {
    var prop_name = expect_word();
    var type = parse_idl_type();
    expect_token("BRA_OPEN");
    var token = lexer.read;
    var read = [];
    var write = [];
    if token.token == "READ" {
        read = parse_idl_binding();
        token = lexer.read;
    }
    if token.token == "WRITE" {
        write = parse_idl_binding();
        token = lexer.read;
    }
    if token.token != "BRA_CLOSE" {
        idl_error("Expected BRA_CLOSE but got {token.token}");
    }
    return ["prop", prop_name, read, write];
}

fn parse_idl_fn(): object {
    var fn_name = expect_word();
    var bindings = [];
    var args;
    var binding;
    var return_type;
    if lexer.peek.token == "BRA_OPEN" {
        expect_token("BRA_OPEN");
        loop {
            if lexer.peek.token == "BRA_CLOSE" {
                break;
            }
            args = parse_idl_args();
            return_type = parse_idl_type();
            binding = parse_idl_binding();
            append(bindings, [args, return_type, binding]);
        }
        expect_token("BRA_CLOSE");
    } else {
        args = parse_idl_args();
        return_type = parse_idl_type();
        binding = parse_idl_binding();
        append(bindings, [args, return_type, binding]);
    }
    var fn_list = ["fn", fn_name, bindings];
    idl_log("fn: {fn_list}");
    return fn_list;
}

fn parse_idl_handler(): object {
    var name = expect_word();
    expect_token("PAREN_OPEN");
    if lexer.peek.token != "PAREN_CLOSE" {
        loop {
            var param_name = expect_word();
            var param_type = parse_idl_type();
            if lexer.peek.token == "PAREN_CLOSE" {
                break;
            }
            expect_token("COMMA");
        }
    }
    expect_token("PAREN_CLOSE");
    var return_type = parse_idl_type();
    expect_token("SEMI");
    var handler_list = ["handler", name, return_type];
    idl_log("handler: {handler_list}");
    return handler_list;
}

fn parse_idl_const(): object {
    var name = expect_word();
    var const_type = parse_idl_type();
    expect_token("EQ");
    var value = lexer.read.string;
    expect_token("SEMI");
    var const_list = ["const", name, const_type, value];
    idl_log("const: {const_list}");
    return const_list;
}

fn parse_idl_object(): object {
    var name = expect_word();
    var items = [];
    expect_token("BRA_OPEN");
    loop {
        if lexer.peek.token == "BRA_CLOSE" {
            break;
        }
        var token = lexer.read;
        if token.token == "PROP" {
            var prop = parse_idl_prop();
            append(items, prop);
        } else {
            idl_error("Unexpected token in idl object block: {token.token}");
        }
    }
    expect_token("BRA_CLOSE");
    return ["object", name, items];
}

fn parse_idl_module(): object {
    var name = expect_word();
    var module = [];
    expect_token("BRA_OPEN");
    loop {
        var token = lexer.read;
        var item;
        if token.token == "BRA_CLOSE" {
            break;
        } else if token.token == "FN" {
            item = parse_idl_fn();
            append(module, item);
        } else if token.token == "PROP" {
            item = parse_idl_prop();
            append(module, item);
        } else if token.token == "HANDLER" {
            item = parse_idl_handler();
            append(module, item);
        } else if token.token == "CONST" {
            item = parse_idl_const();
            append(module, item);
        } else if token.token == "OBJECT" {
            item = parse_idl_object();
            append(module, item);
        } else {
            idl_error("Unexpected token in idl module block: {token.token}");
        }
    }
    return ["module", name, module];
}

fn parse_idl_block(): object {
    var prefix = "";
    var dispatch = "";
    var modules = [];

    loop {
        if lexer.peek.token == "BRA_CLOSE" {
            break;
        }
        var token = lexer.read;
        if token.token == "PREFIX" {
            token = expect_token("STRING_LITERAL");
            prefix = token.string;
            expect_token("SEMI");
        } else if token.token == "DISPATCH" {
            token = expect_token("NAME");
            dispatch = "name";
            expect_token("SEMI");
        } else if token.token == "MODULE" {
            var module = parse_idl_module();
            append(modules, module);
        } else {
            idl_error("Unexpected token in idl block: {token.token}");
        }
    }

    return ["idl", prefix, dispatch, modules];
}

export fn parse_idl(lexer_) {
    lexer = lexer_;
    expect_token("IDL");
    expect_token("BRA_OPEN");
    var idl = parse_idl_block();
    print("{idl}");
    expect_token("BRA_CLOSE");
    lexer = 0;
}
