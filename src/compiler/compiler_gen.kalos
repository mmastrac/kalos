# import module;
# import kidl;
# TODO: Fix duplicate import error
# import file;

var in_object = false;
var in_module = false;
var is_dynamic = false;
var is_internal = false;
var dispatch = "";
var dynamic_dispatch = "";
var current_module;
var undef = "";

# Why so many weird macros?

# The IDL compiler makes use of macros to assist with self-hosting development. It can be
# painful to update the dispatch-generating code at the same time as changes are being made
# to the dispatch interface. Macros de-couple the generated code somewhat from the interface
# and allow much simpler hand-edits to be made for bootstrapping purposes.

const FORWARD = "forward";  # Forward declaration phase
const IMPL = "impl";        # Implementation phase
const HANDLE = "handler";
const DISPATCH = "dispatch";
const OBJECT = "object";
const TYPES = [
    ["string",  "STRING",   "kalos_string", "*",      "kalos_string_release((kalos_state*)state, x);"],
    ["number",  "NUMBER",   "kalos_int", "",          ";"],
    ["bool",    "BOOL",     "kalos_int", "",          ";"],
    ["object",  "OBJECT",   "kalos_object_ref", "*",  "kalos_object_release((kalos_state*)state, &x);"],
    ["any",     "ANY",      "kalos_value", "*",       "kalos_clear((kalos_state*)state, &x);"],
];

var f;

fn fprintln(s) {
    file.write(f, s + "\n");
}

fn fprint(s) {
    file.write(f, s);
}

fn write_matcher(id, name, arg_count) {
    fprintln("\tif (K__match(/*id=*/{id}, /*args=*/{arg_count}, /*name=*/{name})) {{");
}

fn write_binding(binding, arg_types, vararg_type) {
    var index = 0;
    var arg;
    if binding.type == "c" {
        var c = binding.value;
        for arg in arg_types {
            c = replace(c, "@" + index, "(K__arg_{arg}(K__arg(arg_count, {index+1})))");
            index += 1;
        }
        if (c) {
            fprint("({c})");
        }
    } else {
        fprint("{binding.value}((void*)state");
        if (is_internal) {
            fprint(", op");
        }
        for arg in arg_types {
            fprint(", K__arg_{arg}(K__arg(arg_count, {index+1}))");
            index += 1;
        }
        if vararg_type != "void" {
            fprint(", vararg_count, kalos_stack_vararg_start(stack, vararg_count)");
        }
        fprint(")");
    }
}

fn write_invoke(args, arg_count, varargs, return_type, binding) {
    if varargs == "void" {
        fprintln("\t\tconst int arg_count = {arg_count};");
    } else {
        fprintln("\t\tconst int vararg_count = kalos_stack_vararg_count(stack);");
        fprintln("\t\tconst int arg_count = {arg_count + 1} + vararg_count;");
    }
    fprint("\t\tif (kalos_stack_setup_{arg_count}(state, arg_count");
    var arg;
    for arg in args {
        fprint(", K__t_{arg}");
    }
    fprintln(")) {{");
    fprint("\t\t\t");
    if return_type != "void" {
        fprint("K__{return_type} x = ");
    }
    write_binding(binding, args, varargs);
    fprintln(";");
    fprintln("\t\t\tkalos_stack_cleanup(state, arg_count);");
    if return_type != "void" {
        fprintln("\t\t\tK__final_{return_type}(stack, x);");
    }
    fprintln("\t\t\treturn true;");
    fprintln("\t\t}}");
    fprintln("\t}}");
    fprintln("");
}

fn define_args(prefix, args, name, value) {
    fprintln("#define {prefix + name + args:<25} {value}");
    undef += "#undef {prefix + name}\n";
}

fn define(prefix, name, value) {
    fprintln("#define {prefix + name:<15} {value}");
    undef += "#undef {prefix + name}\n";
}

fn open(flags) {
    is_dynamic = flags == 1;
    is_internal = flags == 2;
    fprintln("/* Generated by kalos_idl_compiler - DO NOT MODIFY */");
    fprintln("");
    var type;
    for type in TYPES {
        define("K__p", type[0], type[2] + type[3]);
        define("K__", type[0], type[2]);
    }
    fprintln("");
    for type in TYPES {
        define("K__t_", type[0], "KALOS_VALUE_{type[1]}");
    }
    fprintln("");
    for type in TYPES {
        if is_internal {
            define_args("K__final_", "(stack, x)", type[0], "push_{type[0]}(stack, x);");
        } else {
            define_args("K__final_", "(stack, x)", type[0], "if (retval) {{ push_{type[0]}(stack, x); }} else {{ {type[4]}; }}");
        }
    }
    define_args("K__arg",  "(n, x)", "",    "peek(stack, (n)-(x))");
    define_args("K__arg_", "(x)",    "string", "&((x)->value.string)");
    define_args("K__arg_", "(x)",    "number", "(x)->value.number");
    define_args("K__arg_", "(x)",    "bool",   "(x)->value.number");
    define_args("K__arg_", "(x)",    "object", "&((x)->value.object)");
    define_args("K__arg_", "(x)",    "any",    "(x)");

    if flags == 0 {
        # Standard mode
        define_args("K__match", "(id, n, s)", "", "(param_count == n && function == id)");
    } else if flags == 1 {
        # Dynamic mode
        define_args("K__match", "(id, n, s)", "", "(param_count == n && strcmp(name, #s) == 0)");
    } else if flags == 2 {
        # Internal mode
        define_args("K__match", "(id, n, s)", "", "(op == KALOS_OP_##s)");
    }
    fprintln("");
    kidl.walk_modules(FORWARD);
    kidl.walk_modules(IMPL);
}

fn close {
    if is_dynamic {
        fprintln("bool {kidl.prefix}dynamic_dispatch(kalos_run_state* state, const char* module, const char* name, int param_count, kalos_stack* stack, bool retval) {{");
        fprintln(dynamic_dispatch);
        fprintln("\tLOG(\"Module %s not found\", module);");
        fprintln("\treturn false;");
        fprintln("}}");
        fprintln("");
    } else if !is_internal {
        fprintln("kalos_dispatch_fn {kidl.prefix}dispatch[] = {{");
        fprint(dispatch);
        fprintln("}};");
        fprintln("");
    }
    fprint(undef);
}

on module.begin(context, m) {
    current_module = m;
    if context == IMPL {
        dispatch += "\t{kidl.prefix}{m.name},\n";
        module.walk_exports(HANDLE);
        if is_dynamic {
            dynamic_dispatch += "\tif (strcmp(module, \"{m.name}\") == 0) {{ return {kidl.prefix}{m.name}_dynamic_dispatch(state, name, param_count, stack, retval); }}\n";
            fprintln("bool {kidl.prefix}{m.name}_dynamic_dispatch(kalos_run_state* state, const char* name, int param_count, kalos_stack* stack, bool retval) {{");
        } else if is_internal {
            fprintln("static inline bool {kidl.prefix}{m.name}(kalos_run_state* state, kalos_op op, kalos_stack* stack) {{");
        } else {
            fprintln("bool {kidl.prefix}{m.name}(kalos_run_state* state, int function, int param_count, kalos_stack* stack, bool retval) {{");
        }
        in_module = true;
        module.walk_exports(DISPATCH);
        in_module = false;
        fprintln("\treturn false;");
        fprintln("}}");
        fprintln("");
    } else {
        module.walk_exports(FORWARD);
        #fprintln("");
    }
}

on module.handler(context, handler) {
    if context != HANDLE {
        return;
    }
    fprintln("// id={handler.module_index:04x}:{handler.handler_index:04x} name={handler.name}");
    if handler.return_type == "void" {
        fprint("void ");
    } else {
        fprint("K__{handler.return_type} ");
    }
    if current_module.name == "builtin" {
        fprint("{kidl.prefix}trigger_{handler.name}(kalos_run_state* state");
    } else {
        fprint("{kidl.prefix}{current_module.name}_trigger_{handler.name}(kalos_run_state* state");
    }
    var index = 0;
    var arg;
    for arg in handler.args {
        fprint(", K__p{arg} a{index}");
        index += 1;
    }
    fprintln(") {{");
    index = 0;
    for arg in handler.args {
        fprintln("\tkalos_load_arg_{arg}(state, {index}, a{index});");
        index += 1;
    }
    fprintln("\tkalos_trigger_address(state, kalos_make_address({handler.module_index:#x}, {handler.handler_index:#x}), {handler.return_type != "void"});");
    if handler.return_type != "void" {
        fprintln("\tkalos_value return_value = *pop(state->stack);");
        fprintln("\treturn return_value;");
    }

    fprintln("}}");
    fprintln("");
}

on module.object(context, object) {
    if context != HANDLE {
        return;
    }
    fprintln("//{kidl.prefix}{current_module.name}_object_{object.name}_props");
    if is_dynamic {
        fprintln("bool {kidl.prefix}{current_module.name}_object_{object.name}_props_fn(kalos_run_state* state, kalos_object_ref* object, const char* name, int param_count, kalos_stack* stack) {{");
    } else {
        fprintln("bool {kidl.prefix}{current_module.name}_object_{object.name}_props_fn(kalos_run_state* state, kalos_object_ref* object, int function, int param_count, kalos_stack* stack) {{");
    }
    fprintln("\tbool retval = true;");
    in_object = true;
    module.walk_object_properties(OBJECT, object);
    in_object = false;
    fprintln("\treturn false;");
    fprintln("}}");
    fprintln("");
    fprintln("kalos_object_dispatch {kidl.prefix}{current_module.name}_object_{object.name}_props = {{");
    if is_dynamic {
        fprintln("\t.dispatch_name = {kidl.prefix}{current_module.name}_object_{object.name}_props_fn");
    } else {
        fprintln("\t.dispatch_id = {kidl.prefix}{current_module.name}_object_{object.name}_props_fn");
    }
    fprintln("}};");
    fprintln("");
}

on module.function(context, function) {
    if context != DISPATCH {
        return;
    }
    var overload;
    var arg;
    for overload in function.overloads {
        fprintln("\t// id={overload.binding.invoke_id} name={function.name} arg_count={overload.arg_count} binding={overload.binding.type} {overload.binding.value}");
        write_matcher(overload.binding.invoke_id, function.name, overload.arg_count);
        write_invoke(overload.args, overload.arg_count, overload.varargs, overload.return_type, overload.binding);
    }
}

on module.property(context, property) {
    if !in_module && !in_object {
        return;
    }
    if property.read_binding.invoke_id != 0 {
        fprintln("\t// id={property.read_binding.invoke_id} name={property.name} binding={property.read_binding.type} {property.read_binding.value}");
        write_matcher(property.read_binding.invoke_id, property.name, 0);
        if in_object {
            write_invoke(["object"], 1, "void", property.type, property.read_binding);
        } else {
            write_invoke([], 0, "void", property.type, property.read_binding);
        }
    }
    if property.write_binding.invoke_id != 0 {
        fprintln("\t// id={property.write_binding.invoke_id} name={property.name} binding={property.write_binding.type} {property.write_binding.value}");
        write_matcher(property.write_binding.invoke_id, property.name, 1);
        if in_object {
            write_invoke(["object", property.type], 2, "void", "void", property.write_binding);
        } else {
            write_invoke([property.type], 1, "void", "void", property.write_binding);
        }
    }
}

# TODO: Why does the compiler barf if this isn't defined at the bottom?
export fn gen_dispatch(output, idl): void {
    f = output;
    kidl.module = idl;
    open(idl.flags);
    close();
}
