# Generates the dispatch files for interfacing C and Kalos code.

# Why so many weird macros?

# The IDL compiler makes use of macros to assist with self-hosting development. It can be
# painful to update the dispatch-generating code at the same time as changes are being made
# to the dispatch interface. Macros de-couple the generated code somewhat from the interface
# and allow much simpler hand-edits to be made for bootstrapping purposes.

const FORWARD = "forward";  # Forward declaration phase
const IMPL = "impl";        # Implementation phase
const HANDLE = "handler";
const DISPATCH = "dispatch";
const OBJECT = "object";
const TYPES = [
    ["string",  "STRING",   "kalos_string", "*",      "kalos_string_release((kalos_state*)state, x);"],
    ["number",  "NUMBER",   "kalos_int", "",          ";"],
    ["bool",    "BOOL",     "kalos_int", "",          ";"],
    ["object",  "OBJECT",   "kalos_object_ref", "*",  "kalos_object_release((kalos_state*)state, &x);"],
    ["any",     "ANY",      "kalos_value", "*",       "kalos_clear((kalos_state*)state, &x);"],
];

# Output file
var f;

# Flags
var is_dynamic = false;
var is_internal = false;
var is_standard = false;

var undef = "";
var dispatch = "";
var dynamic_dispatch = "";

fn fprintln(s) {
    file.write(f, s + "\n");
}

fn fprint(s) {
    file.write(f, s);
}

fn idl_dispatch_define_args(prefix, args, name, value) {
    fprintln("#define {prefix + name + args:<25} {value}");
    undef += "#undef {prefix + name}\n";
}

fn idl_dispatch_define(prefix, name, value) {
    fprintln("#define {prefix + name:<15} {value}");
    undef += "#undef {prefix + name}\n";
}

fn idl_dispatch_write_matcher(id, name, arg_count) {
    fprintln("\tif (K__match(/*id=*/{id}, /*args=*/{arg_count}, /*name=*/{name})) {{");
}

fn idl_dispatch_map_arg_types(args): object {
    var arg_types = [];
    var arg;
    for arg in args {
        var type = arg.type;
        if !arg.is_vararg {
            append(arg_types, type);
        }
    }
    return arg_types;
}

fn idl_dispatch_write_binding_call(binding, arg_types, vararg_type) {
    var index = 0;
    var arg;
    if binding.type == "c" {
        var c = binding.string;
        for arg in arg_types {
            c = replace(c, "@" + index, "(K__arg_{arg}(K__arg(arg_count, {index+1})))");
            index += 1;
        }
        if (c) {
            fprint("({c})");
        }
    } else {
        fprint("{binding.string}((void*)state");
        if (is_internal) {
            fprint(", op");
        }
        for arg in arg_types {
            fprint(", K__arg_{arg}(K__arg(arg_count, {index+1}))");
            index += 1;
        }
        if vararg_type != "void" {
            fprint(", vararg_count, kalos_stack_vararg_start(stack, vararg_count)");
        }
        fprint(")");
    }
}

fn idl_dispatch_write_invoke(args, varargs, return_type, binding) {
    var arg_count = len(args);
    if varargs == "void" {
        fprintln("\t\tconst int arg_count = {arg_count};");
    } else {
        fprintln("\t\tconst int vararg_count = kalos_stack_vararg_count(stack);");
        fprintln("\t\tconst int arg_count = {arg_count + 1} + vararg_count;");
    }
    fprint("\t\tif (kalos_stack_setup_{arg_count}(state, arg_count");
    var arg;
    for arg in args {
        fprint(", K__t_{arg}");
    }
    fprintln(")) {{");
    fprint("\t\t\t");
    if return_type != "void" {
        fprint("K__{return_type} x = ");
    }
    idl_dispatch_write_binding_call(binding, args, varargs);
    fprintln(";");
    fprintln("\t\t\tkalos_stack_cleanup(state, arg_count);");
    if return_type != "void" {
        fprintln("\t\t\tK__final_{return_type}(stack, x);");
    }
    fprintln("\t\t\treturn true;");
    fprintln("\t\t}}");
    fprintln("\t}}");
    fprintln("");
}

fn idl_dispatch_write_header(idl) {
    is_dynamic = idl.dispatch == "name";
    is_internal = idl.dispatch == "internal";
    is_standard = !is_dynamic && !is_internal;
    fprintln("/* Generated by kalos_idl_compiler - DO NOT MODIFY */");
    fprintln("");
    var type;
    for type in TYPES {
        idl_dispatch_define("K__p", type[0], type[2] + type[3]);
        idl_dispatch_define("K__", type[0], type[2]);
    }
    fprintln("");
    for type in TYPES {
        idl_dispatch_define("K__t_", type[0], "KALOS_VALUE_{type[1]}");
    }
    fprintln("");
    for type in TYPES {
        if is_internal {
            idl_dispatch_define_args("K__final_", "(stack, x)", type[0], "push_{type[0]}(stack, x);");
        } else {
            idl_dispatch_define_args("K__final_", "(stack, x)", type[0], "if (retval) {{ push_{type[0]}(stack, x); }} else {{ {type[4]}; }}");
        }
    }
    idl_dispatch_define_args("K__arg",  "(n, x)", "",    "peek(stack, (n)-(x))");
    idl_dispatch_define_args("K__arg_", "(x)",    "string", "&((x)->value.string)");
    idl_dispatch_define_args("K__arg_", "(x)",    "number", "(x)->value.number");
    idl_dispatch_define_args("K__arg_", "(x)",    "bool",   "(x)->value.number");
    idl_dispatch_define_args("K__arg_", "(x)",    "object", "&((x)->value.object)");
    idl_dispatch_define_args("K__arg_", "(x)",    "any",    "(x)");

    if is_standard {
        # Standard mode
        idl_dispatch_define_args("K__match", "(id, n, s)", "", "(param_count == n && function == id)");
    } else if is_dynamic {
        # Dynamic mode
        idl_dispatch_define_args("K__match", "(id, n, s)", "", "(param_count == n && strcmp(name, #s) == 0)");
    } else if is_internal {
        # Internal mode
        idl_dispatch_define_args("K__match", "(id, n, s)", "", "(op == KALOS_OP_##s)");
    }
    fprintln("");
}

fn idl_dispatch_write_footer(idl) {
    if is_dynamic {
        fprintln("bool {idl.prefix}dynamic_dispatch(kalos_run_state* state, const char* module, const char* name, int param_count, kalos_stack* stack, bool retval) {{");
        fprintln(dynamic_dispatch);
        fprintln("\tLOG(\"Module %s not found\", module);");
        fprintln("\treturn false;");
        fprintln("}}");
        fprintln("");
    } else if !is_internal {
        fprintln("kalos_dispatch_fn {idl.prefix}dispatch[] = {{");
        fprint(dispatch);
        fprintln("}};");
        fprintln("");
    }
    fprint(undef);
}

fn idl_dispatch_walk_function(idl, context, module, module_context, function) {
    if module_context != DISPATCH {
        return;
    }
    var overload;
    var arg;
    for overload in function.overloads {
        var arg_count = len(overload.args);
        var vararg_type = "void";
        var arg;
        for arg in overload.args {
            if arg.is_vararg {
                vararg_type = arg.type;
                arg_count -= 1;
            }
        }
        fprintln("\t// id={overload.binding.invoke_id} name={function.name} arg_count={arg_count} binding={overload.binding.type} {overload.binding.string}");
        idl_dispatch_write_matcher(overload.binding.invoke_id, function.name, arg_count);
        var arg_types = idl_dispatch_map_arg_types(overload.args);
        idl_dispatch_write_invoke(arg_types, vararg_type, overload.return_type, overload.binding);
    }
}

fn idl_dispatch_walk_property(idl, context, module, module_context, in_object, property) {
    if module_context != DISPATCH {
        return;
    }
    if property.read_binding.type != "none" {
        fprintln("\t// id={property.read_binding.invoke_id} name={property.name} binding={property.read_binding.type} {property.read_binding.string}");
        idl_dispatch_write_matcher(property.read_binding.invoke_id, property.name, 0);
        if in_object {
            idl_dispatch_write_invoke(["object"], "void", property.type, property.read_binding);
        } else {
            idl_dispatch_write_invoke([], "void", property.type, property.read_binding);
        }
    }
    if property.write_binding.type != "none" {
        fprintln("\t// id={property.write_binding.invoke_id} name={property.name} binding={property.write_binding.type} {property.write_binding.string}");
        idl_dispatch_write_matcher(property.write_binding.invoke_id, property.name, 1);
        if in_object {
            idl_dispatch_write_invoke(["object", property.type], "void", "void", property.write_binding);
        } else {
            idl_dispatch_write_invoke([property.type], "void", "void", property.write_binding);
        }
    }
}

fn idl_dispatch_walk_handler(idl, context, module, module_context, handler) {
    if module_context != HANDLE {
        return;
    }
    fprintln("// id={module.invoke_id:04x}:{handler.invoke_id:04x} name={handler.name}");
    if handler.return_type == "void" {
        fprint("void ");
    } else {
        fprint("K__{handler.return_type} ");
    }
    if module.name == "builtin" {
        fprint("{idl.prefix}trigger_{handler.name}(kalos_run_state* state");
    } else {
        fprint("{idl.prefix}{module.name}_trigger_{handler.name}(kalos_run_state* state");
    }
    var index = 0;
    var arg;
    for arg in handler.args {
        fprint(", K__p{arg.type} a{index}");
        index += 1;
    }
    fprintln(") {{");
    index = 0;
    for arg in handler.args {
        fprintln("\tkalos_load_arg_{arg.type}(state, {index}, a{index});");
        index += 1;
    }
    fprintln("\tkalos_trigger_address(state, kalos_make_address({module.invoke_id:#x}, {handler.invoke_id:#x}), {handler.return_type != "void"});");
    if handler.return_type != "void" {
        fprintln("\tkalos_value return_value = *pop(state->stack);");
        fprintln("\treturn return_value;");
    }

    fprintln("}}");
    fprintln("");
}

fn idl_dispatch_walk_object(idl, context, module, module_context, object) {
    if module_context != HANDLE {
        return;
    }
    fprintln("//{idl.prefix}{module.name}_object_{object.name}_props");
    if is_dynamic {
        fprintln("bool {idl.prefix}{module.name}_object_{object.name}_props_fn(kalos_run_state* state, kalos_object_ref* object, const char* name, int param_count, kalos_stack* stack) {{");
    } else {
        fprintln("bool {idl.prefix}{module.name}_object_{object.name}_props_fn(kalos_run_state* state, kalos_object_ref* object, int function, int param_count, kalos_stack* stack) {{");
    }
    fprintln("\tbool retval = true;");

    var item;
    for item in object.items {
        if item.class == "prop" {
            idl_dispatch_walk_property(idl, context, module, DISPATCH, true, item);
        }
    }

    fprintln("\treturn false;");
    fprintln("}}");
    fprintln("");
    fprintln("kalos_object_dispatch {idl.prefix}{module.name}_object_{object.name}_props = {{");
    if is_dynamic {
        fprintln("\t.dispatch_name = {idl.prefix}{module.name}_object_{object.name}_props_fn");
    } else {
        fprintln("\t.dispatch_id = {idl.prefix}{module.name}_object_{object.name}_props_fn");
    }
    fprintln("}};");
    fprintln("");
}

fn idl_dispatch_walk_exports(idl, context, module, module_context) {
    var item;
    for item in module.items {
        if item.class == "handler" {
            idl_dispatch_walk_handler(idl, context, module, module_context, item);
        } else if item.class == "prop" {
            idl_dispatch_walk_property(idl, context, module, module_context, false, item);
        } else if item.class == "fn" {
            idl_dispatch_walk_function(idl, context, module, module_context, item);
        } else if item.class == "object" {
            idl_dispatch_walk_object(idl, context, module, module_context, item);
        }
    }
}

fn idl_dispatch_walk_module(idl, context, module) {
    var name = module.name;
    if context == IMPL {
        dispatch += "\t{idl.prefix}{name},\n";
        idl_dispatch_walk_exports(idl, context, module, HANDLE);
        if is_dynamic {
            dynamic_dispatch += "\tif (strcmp(module, \"{name}\") == 0) {{ return {idl.prefix}{name}_dynamic_dispatch(state, name, param_count, stack, retval); }}\n";
            fprintln("bool {idl.prefix}{name}_dynamic_dispatch(kalos_run_state* state, const char* name, int param_count, kalos_stack* stack, bool retval) {{");
        } else if is_internal {
            fprintln("static inline bool {idl.prefix}{name}(kalos_run_state* state, kalos_op op, kalos_stack* stack) {{");
        } else {
            fprintln("bool {idl.prefix}{name}(kalos_run_state* state, int function, int param_count, kalos_stack* stack, bool retval) {{");
        }
        idl_dispatch_walk_exports(idl, context, module, DISPATCH);
        fprintln("\treturn false;");
        fprintln("}}");
        fprintln("");
    } else {
        idl_dispatch_walk_exports(idl, context, module, FORWARD);
    }
}

fn idl_dispatch_walk_modules(idl, context) {
    var module;
    for module in idl.modules {
        idl_dispatch_walk_module(idl, context, module);
    }
}

export fn write_dispatch(output, idl): void {
    f = output;
    idl_dispatch_write_header(idl);
    idl_dispatch_walk_modules(idl, FORWARD);
    idl_dispatch_walk_modules(idl, IMPL);
    idl_dispatch_write_footer(idl);
}
